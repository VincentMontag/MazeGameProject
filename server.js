// ==================================================MACE VARIABLES===========================================
const maze = require("./Maze.js");
var WIDTH = 35;
var HEIGHT = 20;
var REFRESHING_TIME = 10000;
var Direction = require('./Direction.js');
// ===========================================================================================================

// ==================================================RACE VARIABLES===========================================
var RACE_SIZE = 2;
var REQUESTED_RACE_SIZE = 2;
var MAX_RACE_TIME = 120000;
var MAX_START_TIME = 20000;
var TIMER_ID = 0;
var WAITING_TIMER_ID = 0;
var RACE_WAIT_ON = RACE_SIZE;
var RACE_START_TIME = -1;
var FIRST_RACER_REACHED_TARGET = false;	
var FIRST_PLAYER_ENTERED_RACE = false;
var RACE_RUNNING = false;
var WAIT_ON_CONNECTION = 0;
var racersDone = 0;
var racers = {};
var racersScore = [];
var waitingRacers = {};
// ===========================================================================================================
 
// ==================================================EXPRESS SERVER===========================================
const express = require("express");
const server = express();
const cookieparser = require("cookie-parser");
const fs = require("fs");
const path = require("path");
const WebSocket = require("ws");
//============================================================================================================

//==================================================INTRODUCTION==============================================
console.log("Welcome to 'Maze-Race in Space'!");
console.log();
console.log("You can change some settings of the game via the following commands.");
console.log("The console will show 'promt: s: ' which means that you can type the command.");
console.log("After this 'v: ' is shown which means that you can type the value now.");
console.log("There could be some logs generated by the server in between.")
console.log();
console.log("newRace -> stops the current race and starts a new one");
console.log("maxRaceTime -> the time before a race terminates although not every player has reached the target");
console.log("raceSize -> sets the requested race size. It is applied when a new race is starting")
console.log("refreshTime -> the time in milliseconds the maze refreshes itself automatically");
console.log("bonusSteps -> the number of times a player can drive through walls after tha maze has been generated again");
console.log();
//============================================================================================================

//==================================================SERVER CONFIG=============================================
server.use(cookieparser());
// The folder with all html files
server.use(express.static("."));
server.set("view engine", "ejs");
// render the ejs views
server.set("views", path.join("views"));
// allow the express server to process POST request
server.use(express.json());
server.use(express.urlencoded({ extended: true }));
// Portnumber
portnumber = 8082;
// WebSocket
const serverSocket = new WebSocket.Server({ port: (portnumber + 1) });
// Server start
server.listen(portnumber, function ()  {
    console.log('listening at port ' + portnumber);
});
// ===========================================================================================================

// =============================================PLAYER DATA===================================================
players1 = {}
// ===========================================================================================================

//=========================================CHANGABLE SERVER SETTINGS==========================================
var prompt = require('prompt');
prompt.start();

function setSetting(setting) {
	if (setting.s == 'raceSize') {
		REQUESTED_RACE_SIZE = Number(setting.v);
	} else if (setting.s == "newRace") {
		newRace(0);
	} else if (setting.s == "maxRaceTime") {
		MAX_RACE_TIME = Number(setting.v);	
	} else if (setting.s == "refreshTime") {
		REFRESHING_TIME = Number(setting.v);
	} else if (setting.s == "bonusSteps") {
		maze.setBonusSteps(Number(setting.v));
	}
	promptGetter().then(setSetting);
}

function promptGetter() {
	return prompt.get(['s', 'v']);
}

promptGetter().then(setSetting);
//============================================================================================================

// Generates the maze
sendMazeToClients();

// Start
server.get("/", (req, res) => {
    data = fs.readFileSync("Start.html", { encoding: 'utf8', flag: 'r' });
    res.send(data);
});

server.get("/getHighscore", (req, res) => { 
	res.send(JSON.stringify(maze.getHighscores()));
});

server.get("/getRaceData", (req, res) => {
	res.send(JSON.stringify(racersScore));
});

server.get("/getSolution", (req, res) => {
	res.send(JSON.stringify(maze.getSolution()));
});

server.post("/resume", (req, res) => {
	let session_id = req.cookies.session_id;
	if (session_id === undefined || players1[session_id] === undefined) {
		res.send("NO_DATA");
	} else {
		console.log("player "+players1[session_id]+" goes on playing");
		players1[session_id].status = 'playing';
		sendPlayerDataToEveryone(serverSocket, session_id);
		res.send();	
	}
});

function validName(input) {
	return /^[A-Za-z]{1,10}$/.test(input);
}

// Mark the player dead
server.post("/restart", (req, res) => {
	console.log("restart");	
	let session_id = req.cookies.session_id;
	if (session_id !== undefined && players1[session_id] !== undefined) {
		players1[session_id].status = 'dead';
		sendPlayerDataToEveryone(serverSocket, session_id);
		delete players1[session_id];
	}
	if (!validName(req.body.name)) {
		res.send("INVALID");
		return;
	}
	if (usernameAlreadyUsed(req.body.name)) {
		res.send("ALREADY_USED");
		return;
	}	
	session_id = JSON.stringify(Math.random());
	res.cookie("session_id", session_id);
	maze.addPlayer(session_id, req.body.name);
	let playerData = {
		username: req.body.name,
		rocket: getImagePath(req.body.rocket),
		left: maze.getX(session_id),
		top: maze.getY(session_id),
		direction: 90,
		status: 'playing'
	}
	players1[session_id] = playerData;
	console.log("Player entered server: "+playerData.username+" ("+session_id+")");
	sendPlayerDataToEveryone(serverSocket, session_id);
	res.send();
});

// Mark the player sleeping
server.post("/markSleeping", (req, res) => {
	let session_id = req.cookies.session_id;
	// In general the data should be available
	if (session_id !== undefined && players1[session_id] !== undefined) {
		console.log(players1[session_id].username+" is sleeping");
		players1[session_id].status = 'sleeping';
		
		// Remove his racing entry if the player was in a race
		if (racers[session_id] !== undefined)
			racerLeftGame(session_id);
		
		sendPlayerDataToEveryone(serverSocket, session_id);
	}
	res.send();
});

//===============================================RACING METHODS===============================================

// Actually, this post event is triggered after a getIn event automatically
server.post("/startRace", (req, res) => {
	let session_id = req.cookies.session_id;
	
	if (session_id === undefined || players1[session_id] === undefined) {
		res.send("NO_DATA");
		return;
	}
	
	// The player object the maze.js works with
	let player = maze.getPlayer(session_id);
	
	// The JSON contains a placeholder for the socket for being able 
	// to send information about the race to the player
	racers[session_id] = {
		playerObject: player,
		socket: null
	}
	
	// The player can't move while this is true
	// If he sends a move he request, his data won't be updated
	player.wait = true;
	
	if (RACE_WAIT_ON == 0) {
		// There is a race currently. So let the player look and add him to the waitingRacers queue.
		waitingRacers[session_id] = racers[session_id]
	} else {
		RACE_WAIT_ON--;	
		
		if (!FIRST_PLAYER_ENTERED_RACE) {
			FIRST_PLAYER_ENTERED_RACE = true;
			WAITING_TIMER_ID = setTimeout(newRace, MAX_START_TIME, 1);
		} 
			
		// The race is starting now
		if (RACE_WAIT_ON == 0)
			WAIT_ON_CONNECTION = session_id;
		else 
			for (key in racers)
				sendRaceWaitOn(racers[key].socket);	
	}	
	res.send();
});

// The player returned and has an entry in the racers dictionary
function racerLeftGame(session_id) {
	// He left while he was waiting on other players
	if (RACE_WAIT_ON > 0) {
		RACE_WAIT_ON++;
		delete racers[session_id];
	// He left while he was waiting on the next race
	} else if (waitingRacers[session_id] !== undefined) {
		delete waitingRacers[session_id];
		delete racers[session_id];
	// He left during the game
	} else {
		racersDone++;			
		delete racers[session_id];
		if (racersDone == RACE_SIZE) newRace(0);
	}
}

// The player reached the target field
function racerDone(id, socket) {
	delete racers[id];
	
	// First player reached target -> delete old highscore list
	if (!FIRST_RACER_REACHED_TARGET) {
		racersScore.splice(0, racersScore.length);
		FIRST_RACER_REACHED_TARGET = true;
	}

	// score
	let t = Date.now() - RACE_START_TIME;
	racersScore.push({
		name: players1[id].username,
		time: (t - (t % 1000)) / 1000
	});

	// send him feedback
	sendRaceWinDataToPlayer(socket);
						
	racersDone++;
	if (racersDone == RACE_SIZE) newRace(0);	
}

function newRace(timeOut) {
	// Send message that race is over
	console.log("new race started with timeOut value "+timeOut);
	for (key in racers)
		sendRaceIsOver(racers[key].socket);
	// Clear all
	racers = {}
	racersDone = 0;
	RACE_SIZE = REQUESTED_RACE_SIZE;
	RACE_WAIT_ON = RACE_SIZE;	
	RACE_RUNNING = false;
	FIRST_RACER_REACHED_TARGET = false;
	if (timeOut == 2) clearTimeout(TIMER_ID);
	
	// Add waiting racers to the racers
	for (key in waitingRacers) {
		if (RACE_WAIT_ON > 0) {
			racers[key] = waitingRacers[key];
			delete waitingRacers[key];
			RACE_WAIT_ON--;
		} else {
			break;
		}
	}
	
	// Send how many players still have to join
	for (key in racers)
		sendRaceWaitOn(racers[key].socket);			
	
	// Start new race
	if (RACE_WAIT_ON == 0) {
		for (key in racers)
			racers[key].playerObject.wait = false;
		RACE_START_TIME = Date.now();	
		TIMER_ID = setTimeout(newRace, MAX_RACE_TIME, 2);
		RACE_RUNNING = true;
	}
}

// A player built the WebSocket connection and has an entry in the racers dictionary
function handleRaceOnConnection(id, socket) {
	// Players are still waiting
	if (!RACE_RUNNING) {
		// WAIT_ON_CONNECTION has been set to the racer which triggers the starting event
		if (id == WAIT_ON_CONNECTION) {
			// Set them startable
			for (key in racers) {
				racers[key].playerObject.wait = false;
				sendRaceWaitOn(racers[key].socket);	
			}
			RACE_START_TIME = Date.now();
			TIMER_ID = setTimeout(newRace, MAX_RACE_TIME, 2);
			RACE_RUNNING = true;
			clearTimeout(WAITING_TIMER_ID);
		} else {
			sendRaceWaitOn(socket);
		}
	// The player must wait until the race is over
	} else {
		sendRaceStillRunning(socket);
	}
}

//============================================================================================================

serverSocket.on('connection', function (socket) {
	console.log("WebSocket connection built");
	sendMazeToClient(socket);
	
	socket.onmessage = function incoming(event) {
		var action;	
		
		// Check if it is a valid message	
		try {
			action = JSON.parse(event.data);
		} catch(err) {
			return;
		}
		if (action.id === undefined || players1[action.id] === undefined || action.dir === undefined ||
		(action.dir != "" && action.dir != "RIGHT" && action.dir != "LEFT" && 
		action.dir != "DOWN" && action.dir != "UP" )) return;
			
		// Initial movement (A player joined the game)
		if (action.dir == "") {
			
			// Set/update the socket in the racing entry and handle the race
			if (racers[action.id] !== undefined) {
				racers[action.id].socket = socket;	
				handleRaceOnConnection(action.id, socket);
			}
			
			// Send the data of all active players to the new one
			// Possible, this command can already be executed after "sendMazeToClient"
			sendDataFromEveryoneToPlayer(socket);
			
			// Send the data of the new one to all active players
			sendPlayerDataToEveryone(serverSocket, action.id);	
				
		// A player wants to move -> if the player is allowed to move the code block is going to be executed
		} else if (maze.movePlayer(action.id, Direction.get(action.dir))) {	
					
			// Update the player data
			players1[action.id].left = maze.getX(action.id);
			players1[action.id].top = maze.getY(action.id);
			players1[action.id].direction = getAngle(action.dir);
					
			// The updated player data is going to be sent to all players including the one who moved
			sendPlayerDataToEveryone(serverSocket, action.id);
			
			// Send win event if the player has reached the target
			if (maze.isDone(action.id)) {
				if (racers[action.id] !== undefined) racerDone(action.id, socket);				
				else sendWinDataToPlayer(socket, maze.getScoreOfPlayer(action.id));
			}			
				
		};		
    };
    socket.onclose = function closing() {
		console.log("close");	
	}
});

//================================================MOVE EVENT===================================================

// If a new player joined the game he has to draw all the active players
function sendDataFromEveryoneToPlayer(socket) {
	for (ids in players1) {		
		let message = {
			type: "MOVE",
			content: players1[ids]
		};
		socket.send(JSON.stringify(message))
	}
}
 
// If a player moved or joined tha game everyone has to update this player data
function sendPlayerDataToEveryone(serverSocket, actionid) {
	let message = {
		type: "MOVE",
		content: players1[actionid]
	};
	serverSocket.clients.forEach(function each(client) {
		client.send(JSON.stringify(message));
	});
}

//===========================================================================================================

//==============================================MAZE CHANGE==================================================

function sendMazeToClients() {
	mazeFields = maze.generateMaze(WIDTH, HEIGHT, false);
	let message = {
		type: "MAZE_CHANGE",
		content: mazeFields
	};
	serverSocket.clients.forEach(function each(client) {
		client.send(JSON.stringify(message));
	});
	setTimeout(sendMazeToClients, REFRESHING_TIME);
}

function sendMazeToClient(client) {
	let message = {
		type: "MAZE_CHANGE",
		content: mazeFields
	};
	client.send(JSON.stringify(message));
}

//===========================================================================================================

//==================================================WIN EVENT================================================

function sendWinDataToPlayer(client, score) {
	let message = {
		type: "WIN",
		content: score
	};
	client.send(JSON.stringify(message));
}

//===========================================================================================================

//==================================================RACE EVENT===============================================

function sendRaceWinDataToPlayer(client) {
	if (client == null) return;
	let message = {
		type: "RACE_WIN",
		content: {t: racersScore[racersScore.length-1].time, p: racersScore.length}
	};
	client.send(JSON.stringify(message));
}

function sendRaceWaitOn(client) {
	if (client == null) return;
	let message = {
		type: "WAIT_ON",
		content: ""+RACE_WAIT_ON
	};
	client.send(JSON.stringify(message));
}

function sendRaceStillRunning(client) {
	if (client == null) return;
	let message = {
		type: "RACE_STILL_RUNNING",
		content: {}
	};
	client.send(JSON.stringify(message));
}

function sendRaceIsOver(client) {
	if (client == null) return;
	let message = {
		type: "RACE_OVER",
		content: {}
	};
	client.send(JSON.stringify(message));
}

//===========================================================================================================

function getImagePath(i) {
	let path = "";
	if (i == 1) path = '../pixelart/player_blue.png';
	else if (i == 2) path = '../pixelart/player_brown.png';
	else if (i == 3) path = '../pixelart/player_green.png';
	else if (i == 4) path = '../pixelart/player_grey.png';
	else if (i == 5) path = '../pixelart/player_petrol.png';
	else if (i == 6) path = '../pixelart/player_pink.png';
	else if (i == 7) path = '../pixelart/player_purple.png';
	else if (i == 8) path = '../pixelart/player_red.png';
	else if (i == 9) path = '../pixelart/player_white.png';
	else if (i == 10) path = '../pixelart/player_yellow.png';
	return path;
}

function getAngle(direction) {
	let angle = 0;
	if (direction == "RIGHT") angle = 90;
	else if (direction == "LEFT") angle = 270;
	else if (direction == "DOWN") angle = 180;
	return angle;
}

function usernameAlreadyUsed(name) {
	for (ids in players1)
		if (players1[ids].username == name) return true;
	return false;
}
